# 객체지향의 사실과 오해

## 목표
객체지향을 철학으로 바라보고, 흔한 오해를 바로잡기

## 객체지향 패러다임
객체지향 패러다임의 핵심은 **자율적인(Automonous) 객체들의 협력**

📍 **Automonous** : 자율적인, 독립적인; **autos** : 자신(self); **nomos** : 법칙, 질서

> 객체는 스스로 자신의 상태를 관리하며 암묵적인 약속과 명시적인 계약을 기반으로 공동의 목표를 달성하기 위해 메세지를 주고받으며 다른 객체와 협력한다.


## 객체(Object)의 종류

1.  엔티티(Entity) / 참조 객체(Reference Object): 식별자가 중요 (예: 주문 ID, 사용자 ID), 보통 객체는 이것을 의미 함.
2.  값 객체(Value Object): 값이 중요, 식별자 없음 (예: Money, Address)

## 객체지향에서의 객체
상태(state)·행동(behavior)·식별자(identity)를 캡슐화한 것

## 왜 객체지향에서 ‘객체’는 참조 객체(엔티티)일까?
- 객체지향은 “누가 무엇을 한다”가 중요
- 그 “누구”가 바로 <u>ID로 구별되는 주체인 <b>참조 객체(엔티티)</b></u>다. 


## 동등성 : 객체가 같다
객체지향에서 “객체가 같다는 게 무엇을 의미하느냐”가 매우 중요하다.
객체는 시간에 따라 변경되는 상태를 포함하며, 행동을 통해 상태를 변경한다. 

이를 <u>"객체는 가변상태(mutable state)를 가진다."</u>라고 말한다.

그럼 “두 객체가 같은가?”를 어떻게 판단할까?

## 자바에서의 동등성 구현 예


엔티티(참조 객체) vs 값 객체 구분에서 → 비교 기준이 다르기 때문에 동등성 개념이 중요!

- User (엔티티): 시스템 내에서 누구를 식별하기 위한 고유 ID 보유

```java
/** 엔티티: 식별자(id)가 객체 정체성을 나타낸다 */
class User {
    private final String id;      // 식별자
    private String name;

    // equals / hashCode — ID만 사용
    @Override
    public boolean equals(Object o) {
        return o instanceof User u && id.equals(u.id);
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }
}    
```

- Money (값 객체): 금액·통화 조합으로 무엇인지 표현, 주로 불변(immutable)

```java
/** 값 객체: 불변(immutable)하고 값 비교 */
class Money {
    private final int amount;
    private final String currency;

    // equals / hashCode — 값 비교
    @Override
    public boolean equals(Object o) {
        return o instanceof Money m && amount == m.amount && currency.equals(m.currency);
    }

    @Override
    public int hashCode() {
        return Objects.hash(amount, currency);
    }
}
```     
> **📍 포인트 : 같은 객체를 판단하는 비교 기준** 
> - <u>엔티티는 누구냐가 중요</u> → ID 기반 비교 
> - <u>값 객체는 무엇이냐가 중요</u> → 상태 전체 기반 비교

### 💡 자바에서 동등성(Equality)

***Equality란?***

- 참조 동일성(==) : 메모리 주소가 같음 → 같은 인스턴스

- 의미적 동등성(equals) : 객체가 의미적으로 같음 → 개발자가 정의

- equals()와 hashCode() 계약
    - equals가 true이면 hashCode도 같아야 함
    - 컬렉션(Set, Map)에서 필수


## 상태(State)와 프로퍼티(Property)

상태를 알면 과거에 어떤 행동을 했었는지 모르더라도 현재를 기반으로 객체의 행동 방식을 이해할 수 있다.

객체는 상태를 외부로 노출시키지 않고, 행동을 노출시키고, 행동의 결과로 스스로의 상태를 변경한다. 이것은 객체의 자율성을 높이고, 객체간의 협력을 유연하고 간결하게 한다.

### 프로퍼티(Property) 
객체의 상태를 구성하는 모든 특징의 집합. 정적 메타정보이며 두 가지로 나뉜다.

1. 속성(Attribute) : 단순 값으로 표현되는 특징 (예: 이름, 금액)

2. 링크(Link) : 다른 객체를 참조하는 포인터 → 연관관계의 인스턴스 (예: 주문 → 고객)

### 프로퍼티의 값(Value)
- 실행 중 동적으로 변할 수 있는 데이터. 시간에 따라 달라질 수 있다.


## 책임 주도 설계(Responsibility-Driven Design, RDD)

행동이 상태를 결정한다. 즉, 객체지향을 데이터가 아니라, 행동(책임) 중심으로 설계하자는 방식 이다.

📍 협력 안에서 객체의 행동은 결국 객체가 협력에 참여하면서 완수해야하는 책임을 의미한다. 따라서 "어떤 책임이 필요한가"를 결정하는 과정이 전체 설계를 주도해야 한다. 

### 핵심 개념 3가지

1. 이 객체는 무슨 책임을 가져야 할까? → 객체는 책임을 가진다
	-	객체는 “어떤 데이터를 담을까?”가 아니라 **“무슨 일을 해야 하지?”** 로 시작해야 한다.

2. 이 책임을 어떻게 수행할까? → 행동이 먼저, 상태는 나중
    - 객체가 하는 **행동(메서드)** 을 먼저 정하고, 그 행동을 **수행하는 데 필요한 상태(필드)** 만 만든다 → **“행동이 상태를 결정한다”** 

3. 누구에게 메시지를 보내서 협력할까? → 객체는 다른 객체와 협력한다
    - 혼자 다 하지 않는다.
    - 필요한 일은 다른 객체에게 메시지를 보내서 요청 한다.

### 예시: 주문 시스템
❌ **잘못된 방식 (데이터 중심)**
```java
class Order {
    String orderId;
    String status;
    LocalDate orderDate;
    List<Item> items;
    // 상태만 가득, 행동은 없음
}
```
→ 이건 그냥 데이터 덩어리 (절차지향과 다를 게 없음)

✅ **책임 주도 방식**
```java
class Order {
    void addItem(Item item);
    void cancel();
    Money calculateTotal();
}
```
→ “주문은 무엇을 할 수 있지?”로 시작<br>
→ 그 다음 “이 행동을 하려면 어떤 정보가 필요하지?”로 상태를 정함


### 책임 주도 설계의 효과

1. 설계가 유연하고 확장 가능

2. 객체는 자기 역할만 신경

3. 협력이 자연스럽고, 테스트하기도 쉬움


## 추상화(Abstraction)

복잡한 현실을 단순한 모델로 표현하는 것.<br>
본질적인 것만 남기고, 불필요한 세부 사항은 감춘다.


📍 **ab-** : ~로부터 떨어져; **trahere** :  끌어당기다, 끌어내다 (to draw)

→ “복잡한 것에서 중요한 것을 끌어낸다”는 의미!<br>
→ 즉, 중요한 특성만 남기고 나머지는 제거한다

***"현상은 복잡하다. 법칙은 단순하다.버릴게 무엇인지 알아내라."***
— 리처드 파인만

### 추상화의 핵심

훌륭한 추상화는 목적에 부합하는 것이다.

- 추상화는 단순화가 아니다 → 복잡한 것을 감추되, 본질은 유지하는 것
- 코드를 적게 쓰는 게 아니라, 생각의 부담을 줄이는 것

### 객체지향에서 추상화는?
객체가 제공하는 <b>행위(인터페이스)</b>만 드러내고, 내부 <b>구현(상태, 알고리즘)</b>은 숨긴다. 이것은 곧 <u>캡슐화와도 연결</u>된다.

## 개념(Concept)이란?

“모든 객체는 개념의 인스턴스이며, 개념은 객체의 본질을 정의한다.”

현실 세계나 도메인에서 공통적으로 식별되는 의미 있는 무언가를 표현한 것<br>
예: “자동차”, “사람”, “주문”, “상품”

객체지향은 이 개념을 코드로 표현하는 방법이고, 그 과정에서 타입(type), 클래스(class), 객체(object)가 만들어진다.

주변의 복잡한 객체들은 단지 몇가지 개념의 인스턴스일 뿐이다!

### 개념의 세 가지 관점

1. 내부 관점 (Intension)
    - 개념이 가지는 본질적인 특징
    - 예: 자동차는 바퀴가 4개, 엔진이 있음

2. 외부 관점 (Extension)
    - 그 개념에 속하는 실제 객체들
	- 예: 아반떼, 캐스퍼 → 자동차 개념의 인스턴스들

3. 표현 관점 (Representation)
    - 개념을 코드로 표현한 것
	- 예: class Car {}

### 개념과 추상화, 그리고 타입

좋은 객체지향 모델은 개념을 제대로 식별하고, 표현하는 데서 시작한다.

- 추상화와도 연결 : 어떤 개념의 본질을 남기고, 불필요한 건 지워야 하기 때문
- 타입(type)과 연결 : 타입은 개념이다.
